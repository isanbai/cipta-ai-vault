https://www.coursera.org/learn/python-for-applied-data-science-ai

- Applied Software Engineering Fundamentals

# Python Basic

## Summary

- Python can distinguish among data types such as integers, floats, strings, and Booleans.
- Integers are whole numbers that can be positive or negative.
- Floats are numbers that have decimal points; they can represent whole or fractional values.
- You can convert integers to floats using typecasting and vice-versa.
- You can convert integers and floats to strings.
- You can convert an integer or float to a Boolean: 0 becomes False, non-zero becomes True.
- Expressions in Python are a combination of values and operations used to produce a single result.
- Expressions perform mathematical operations such as addition, subtraction, multiplication, and so on.
- We can use // to perform integer division, which results in an integer value by discarding the fractional part.
- Python follows the order of operations (BODMAS) to perform operations with multiple expressions.
- Variables store and manipulate data, allowing you to access and modify values throughout your code.
- The assignment operator "=" assigns a value to a variable.
- Assigning another value to the same variable overrides the previous value of that variable.
- You can perform mathematical operations on variables using the same or different variables.
- Modifying the value of one variable will affect other variables only if they reference the same mutable object.
- Python string operations involve manipulating text data using tasks such as indexing, concatenation, slicing, and formatting.
- A string is usually written within double quotes or single quotes, including letters, white space, digits, or special characters.
- A string can be assigned to a variable and is an ordered sequence of characters.
- Characters in a string identify their index numbers, which can be positive or negative.
- Strings are sequences that support operations like indexing and slicing.
- You can input a stride value to perform slicing while operating on a string.
- Operations like concatenation and replication produce new strings, while finding the length of a string returns a number.
- You cannot modify an existing string; they are immutable. 
- You can use escape sequences with a backslash (\) to change the layout of a string. (For example, \n for a new line, \t for a tab, and \\ for a backslash, etc.)
- In Python, you perform tasks such as searching, modifying, and formatting text data with its pre-built string methods.
- You apply a method to a string to change its value, resulting in another string. 
- You can perform actions such as changing the case of characters in a string, replacing items in a string, finding items in a string, and so on using pre-built string methods.

## Format Strings in Python

Format strings are a way to inject variables into a string in Python. They are used to format strings and produce more human-readable outputs. There are several ways to format strings in Python:

### String interpolation (f-strings)

Introduced in Python 3.6, f-strings are a new way to format strings in Python. They are prefixed with 'f' and use curly braces {} to enclose the variables that will be formatted. For example:
```python
name = "John"
age = 30
print(f"My name is {name} and I am {age} years old.")
```

This will output:
`My name is John and I am 30 years old.`

### str.format()

This is another way to format strings in Python. It uses curly braces {} as placeholders for variables which are passed as arguments in the format() method. For example:
```python
name = "John"
age = 50
print("My name is {} and I am {} years old.".format(name, age))
```

This will output:
`My name is John and I am 50 years old.`

### % Operator

This is one of the oldest ways to format strings in Python. It uses the % operator to replace variables in the string. For example:
```python
name = "Johnathan"
age = 30
print("My name is %s and I am %d years old." % (name, age))
```

This will output:
`My name is Johnathan and I am 30 years old.`

“**My name is %s and I am %d years old.**“: This is a string that includes format specifiers:

- **%s**: This is a placeholder for a string.
- **%d**: This is a placeholder for an integer.

**% (name, age)**: This is a tuple containing the variables name and age. The values of these variables will replace the placeholders in the string.

Each of these methods has its own advantages and use cases. However, f-strings are generally considered the most modern and preferred way to format strings in Python due to their readability and performance.

### Additional capabilities

F-strings are also able to evaluate expressions inside the curly braces, which can be very handy. For example:
```python
x = 10
y = 20
print(f"The sum of x and y is {x+y}.")
```

This will output:
`The sum of x and y is 30.`

### Raw String (r’’)

In Python, raw strings are a powerful tool for handling textual data, especially when dealing with escape characters. By prefixing a string literal with the letter ‘r’, Python treats the string as raw, meaning it interprets backslashes as literal characters rather than escape sequences.

Consider the following examples of regular string and raw string:

**Regular string:**
```python
regular_string = "C:\new_folder\file.txt"
print("Regular String:", regular_string)
```

This will output:
`Regular String:  C:`
`ew_folderile.txt`

In the regular string regular_string variable, the backslashes (\n) are interpreted as escape sequences. Therefore, \n represents a newline character, which would lead to an incorrect file path representation.

**Raw string:**
```python
raw_string = r"C:\new_folder\file.txt"
print("Raw String:", raw_string)
```

This will output:
`Raw String: C:\new_folder\file.txt`

However, in the raw string raw_string, the backslashes are treated as literal characters. This means that \n is not interpreted as a newline character, but rather as two separate characters, \ and n. Consequently, the file path is represented exactly as it appears.

## Module 1 Cheat Sheet: Python Basics

| Package/Method      | Description                                                                                                                                                                                                                                                                                                                                                                      | Code Example                                                                                                                                                                                                                                                   |
| ------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Comments            | Comments are lines of text that are ignored by the Python interpreter when executing the code<./td>                                                                                                                                                                                                                                                                              | `# This is a comment`                                                                                                                                                                                                                                          |
| Concatenation       | Combines (concatenates) strings.                                                                                                                                                                                                                                                                                                                                                 | Syntax:<br><br>`concatenated_string = string1 + string2` <br><br>Example:<br>`result = "Hello" + " John"</td>`                                                                                                                                                 |
| Data Types          | - Integer - Float - Boolean - String                                                                                                                                                                                                                                                                                                                                             | Example:<br><br>`x=7` <br>`#Integer Value` <br>`y=12.4` <br>`#Float Value` <br>`is_valid = True` <br>`#Boolean Value` <br>`is_valid = False` <br>`#Boolean Value` <br>`F_Name = "John"` <br>`#String Value`                                                    |
| Indexing            | Accesses character at a specific index.                                                                                                                                                                                                                                                                                                                                          | Example:<br><br>`my_string="Hello"` <br>`char = my_string[0]`                                                                                                                                                                                                  |
| len()               | Returns the length of a string.                                                                                                                                                                                                                                                                                                                                                  | Syntax:<br><br>`len(string_name)` <br><br>Example:<br><br>`my_string="Hello"` <br>`length = len(my_string)`                                                                                                                                                    |
| lower()             | Converts string to lowercase.                                                                                                                                                                                                                                                                                                                                                    | Example:<br><br>`my_string="Hello"` <br>`lowercase_text = my_string.lower()`                                                                                                                                                                                   |
| print()             | Prints the message or variable inside `()`.                                                                                                                                                                                                                                                                                                                                      | Example:<br><br>`print("Hello, world")` <br>`print(a+b)`                                                                                                                                                                                                       |
| Python Operators    | - Addition (+): Adds two values together.  <br>- Subtraction (-): Subtracts one value from another.  <br>- Multiplication (*): Multiplies two values.  <br>- Division (/): Divides one value by another, returns a float.  <br>- Floor Division (//): Divides one value by another, returns the quotient as an integer.  <br>- Modulo (%): Returns the remainder after division. | Example:<br><br>`x = 9 y = 4` <br>`result_add= x + y # Addition` <br>`result_sub= x - y # Subtraction` <br>`result_mul= x * y # Multiplication` <br>`result_div= x / y # Division` <br>`result_fdiv= x // y # Floor Division` <br>`result_mod= x % y # Modulo` |
| replace()           | Replaces substrings.                                                                                                                                                                                                                                                                                                                                                             | Example:<br><br>`my_string="Hello"` <br>`new_text = my_string.replace("Hello", "Hi")`                                                                                                                                                                          |
| Slicing             | Extracts a portion of the string.                                                                                                                                                                                                                                                                                                                                                | Syntax:<br><br>`substring = string_name[start:end]` <br><br>Example:<br><br>`my_string="Hello" substring = my_string[0:5]`                                                                                                                                     |
| split()             | Splits string into a list based on a delimiter.                                                                                                                                                                                                                                                                                                                                  | Example:<br><br>`my_string="Hello"` <br>`split_text = my_string.split(",")`                                                                                                                                                                                    |
| strip()             | Removes leading/trailing whitespace.                                                                                                                                                                                                                                                                                                                                             | Example:<br><br>`my_string="Hello"` <br>`trimmed = my_string.strip()`                                                                                                                                                                                          |
| upper()             | Converts string to uppercase.                                                                                                                                                                                                                                                                                                                                                    | Example:<br><br>`my_string="Hello"` <br>`uppercase_text = my_string.upper()`                                                                                                                                                                                   |
| Variable Assignment | Assigns a value to a variable.                                                                                                                                                                                                                                                                                                                                                   | Syntax:<br><br>`variable_name = value` <br><br>Example:<br><br>`name="John" # assigning John to variable name` <br>`x = 5 # assigning 5 to variable x`                                                                                                         |
## Glossary: Python Basics

Welcome! This alphabetized glossary contains many of the terms you'll find within this course. This comprehensive glossary also includes additional industry-recognized terms not used in course videos. These terms are important for you to recognize when working in the industry, participating in user groups, and participating in other certificate programs.

|Term|Definition|
|---|---|
|AI|AI (artificial intelligence) is the ability of a digital computer or computer-controlled robot to perform tasks commonly associated with intelligent beings.|
|Application development|Application development, or app development, is the process of planning, designing, creating, testing, and deploying a software application to perform various business operations.|
|Arithmetic Operations|Arithmetic operations are the basic calculations we make in everyday life like addition, subtraction, multiplication and division. It is also called as algebraic operations or mathematical operations.|
|Array of numbers|Set of numbers or objects that follow a pattern presented as an arrangement of rows and columns to explain multiplication.|
|Assignment operator in Python|Assignment operator is a type of Binary operator that helps in modifying the variable to its left with the use of its value to the right. The symbol used for assignment operator is "=".|
|Asterisk|Symbol "* " used to perform various operations in Python.|
|Backslash|A backslash is an escape character used in Python strings to indicate that the character immediately following it should be treated in a special way, such as being treated as escaped character or raw string.|
|Boolean|Denoting a system of algebraic notation used to represent logical propositions by means of the binary digits 0 (false) and 1 (true).|
|Colon|A colon is used to represent an indented block. It is also used to fetch data and index ranges or arrays.|
|Concatenate|Link (things) together in a chain or series.|
|Data engineering|Data engineers are responsible for turning raw data into information that an organization can understand and use. Their work involves blending, testing, and optimizing data from numerous sources.|
|Data science|Data Science is an interdisciplinary field that focuses on extracting knowledge from data sets which are typically huge in amount. The field encompasses analysis, preparing data for analysis, and presenting findings to inform high-level decisions in an organization.|
|Data type|Data type refers to the type of value a variable has and what type of mathematical, relational or logical operations can be applied without causing an error.|
|Double quote|Symbol “ “ used to represent strings in Python.|
|Escape sequence|An escape sequence is two or more characters that often begin with an escape character that tell the computer to perform a function or command.|
|Expression|An expression is a combination of operators and operands that is interpreted to produce some other value.|
|Float|Python float () function is used to return a floating-point number from a number or a string representation of a numeric value.|
|Forward slash|Symbol “/“ used to perform various operations in Python|
|Foundational|Denoting an underlying basis or principle; fundamental.|
|Immutable|Immutable Objects are of in-built datatypes like int, float, bool, string, Unicode, and tuple. In simple words, an immutable object can’t be changed after it is created.|
|Integer|An integer is the number zero (0), a positive natural number (1, 2, 3, and so on) or a negative integer with a minus sign (−1, −2, −3, and so on.)|
|Manipulate|Is the process of modifying a string or creating a new string by making changes to existing strings.|
|Mathematical conventions|A mathematical convention is a fact, name, notation, or usage which is generally agreed upon by mathematicians.|
|Mathematical expressions|Expressions in math are mathematical statements that have a minimum of two terms containing numbers or variables, or both, connected by an operator in between.|
|Mathematical operations|The mathematical “operation” refers to calculating a value using operands and a math operator.|
|Negative indexing|Allows you to access elements of a sequence (such as a list, a string, or a tuple) from the end, using negative numbers as indexes.|
|Operands|The quantity on which an operation is to be done.|
|Operators in Python|Operators are used to perform operations on variables and values.|
|Parentheses|Parentheses is used to call an object.|
|Replicate|To make an exact copy of.|
|Sequence|A sequence is formally defined as a function whose domain is an interval of integers.|
|Single quote|Symbol ‘ ‘ used to represent strings in python.|
|Slicing in Python|Slicing is used to return a portion from defined list.|
|Special characters|A special character is one that is not considered a number or letter. Symbols, accent marks, and punctuation marks are considered special characters.|
|Stride value|Stride is the number of bytes from one row of pixels in memory to the next row of pixels in memory.|
|Strings|In Python, Strings are arrays of bytes representing Unicode characters.|
|Substring|A substring is a sequence of characters that are part of an original string.|
|Type casting|The process of converting one data type to another data type is called Typecasting or Type Coercion or Type Conversion.|
|Types in Python|Data types are the classification or categorization of data items. It represents the kind of value that tells what operations can be performed on a particular data.|
|Variables|Variables are containers for storing data values.|


# Python Data Structures

## Summary

- In Python, we often use tuples to group related data together. Tuples refer to ordered and immutable collections of elements.
- Tuples are usually written as comma-separated elements in parentheses “()".
- You can include strings, integers, and floats in tuples and access them using both positive and negative indices.
- You can perform operations such as combining, concatenating, and slicing on tuples.
- Tuples are immutable, so you need to create a new tuple to manipulate it.
- Tuples, termed nesting, can include other tuples of complex data types.
- You can access elements in a nested tuple through indexing.
- Lists in Python contain ordered collections of items that can hold elements of different types and are mutable, allowing for versatile data storage and manipulation.
- A list is an ordered sequence, represented with square brackets "[]".
- Lists possess mutability, rendering them akin to tuples.
- A list can contain strings, integers, and floats; you can nest lists within it.
- You can access each element in a list using both positive and negative indexing.
- Concatenating or appending a list will result in the modification of the same list.
- You can perform operations such as adding, deleting, splitting, and so forth on a list.
- You can separate elements in a list using delimiters.
- Aliasing occurs when multiple names refer to the same object.
- You can also clone a list to create another list.
- Dictionaries in Python are key-value pairs that provide a flexible way to store and retrieve data based on unique keys.
- Dictionaries consist of keys and values, both composed of string elements.
- You denote dictionaries using curly brackets.
- The keys necessitate immutability and uniqueness.
- The values may be either immutable or mutable, and they allow duplicates.
- You separate each key-value pair with a comma, and you can use color highlighting to make the key more visible.
- You can assign dictionaries to a variable.
- You use the key as an argument to retrieve the corresponding value.
- You can make additions and deletions to dictionaries.
- You can perform an operation on a dictionary to check the key, which results in a true or false output.
- You can apply methods to obtain a list of keys and values in a dictionary.
- Sets in Python are collections of unique elements, useful for tasks such as removing duplicates and performing set operations like union and intersection. Sets lack order.
- Curly brackets "{}" are helpful for defining elements of a set.
- Sets do not contain duplicate items.
- A list passed through the set function generates a set containing unique elements.
- You use “Set Operations” to perform actions such as adding, removing, and verifying elements in a set.
- You can combine sets using the ampersand "&" operator to obtain the common elements from both sets.
- You can use the Union function to combine two sets, including both the common and unique elements from both sets.
- The sub-set method is used to determine if two or more sets are subsets.

## 📌 Definisi :

- **List 📦** → Struktur data yang berisi koleksi elemen, bisa dari tipe apa pun, seperti kotak terbuka, bisa diisi ulang, ditambah, atau dibuang.
- **Tuple 🔒📦** → Mirip dengan list, kotak terkunci, isinya tidak bisa diganti.
- **Set 🎲** → Koleksi data **unik**, seperti kumpulan kelereng, tidak peduli urutan, yang sama dibuang.
- **Dict 🗂️** → Struktur data pasangan **key-value**, seperti kartu indeks, selalu ada _key_ → _value_.
- **String 🔤** → Urutan karakter (text), deretan huruf, tidak bisa diubah setelah dibuat.
- **Range ➡️** → Representasi urutan angka, jalur angka berurutan, biasanya dipakai buat loop.
- **Boolean** → Hanya punya dua nilai → `True` atau `False`

## 📊 Perbandingan Data Type Koleksi Python

|Data Type|Bentuk Penulisan|Ordered (berurutan)|Mutable (bisa diubah)|Duplikat|Ilustrasi|
|---|---|---|---|---|---|
|**List**|`[1, 2, 3]`|✅ Yes|✅ Yes|✅ Yes|📦📦📦 (bisa ditambah/ubah isi)|
|**Tuple**|`(1, 2, 3)`|✅ Yes|❌ No|✅ Yes|🔒📦📦📦 (isi terkunci)|
|**Set**|`{1, 2, 3}`|❌ No|✅ Yes|❌ No|🎲🎲🎲 (acak, unik saja)|
|**Dict**|`{"a": 1}`|✅ Yes (3.7+)|✅ Yes|Key ❌, Value ✅|🗂️ “nama → Budi”|
|**String**|`"abc"`|✅ Yes|❌ No|✅ Yes|🔤 H I R E J O B|
|**Range**|`range(5)`|✅ Yes|❌ No|✅ Yes|1 → 2 → 3 → 4 → 5|

## Python Data Structures Cheat Sheet

#### List

| Package/Method   | Description                                                                                                                                                                                                                                                 | Code Example                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| ---------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| append()         | The `append()` method is used to add an element to the end of a list.                                                                                                                                                                                       | Syntax:<br><br>`list_name.append(element)` <br><br> <br>Example:<br><br>`fruits = ["apple", "banana", "orange"]` <br>`fruits.append("mango") print(fruits)`                                                                                                                                                                                                                                                                                                                                                      |
| copy()           | The `copy()` method is used to create a shallow copy of a list.                                                                                                                                                                                             | Example 1:<br><br>`my_list = [1, 2, 3, 4, 5]` <br>`new_list = my_list.copy() print(new_list)` <br>`# Output: [1, 2, 3, 4, 5]`<br>`a = [1, 2, 3]`<br>`b = a[:]         # shallow copy`<br>`c = a.copy()     # shallow copy`<br>`d = list(a)      # shallow copy`<br><br>`print(a is b)  # False`                                                                                                                                                                                                                  |
| count()          | The `count()` method is used to count the number of occurrences of a specific element in a list in Python.                                                                                                                                                  | Example:<br><br>`my_list = [1, 2, 2, 3, 4, 2, 5, 2]` <br>`count = my_list.count(2) print(count)` <br>`# Output: 4`                                                                                                                                                                                                                                                                                                                                                                                               |
| Creating a list  | A list is a built-in data type that represents an ordered and mutable collection of elements. Lists are enclosed in square brackets [] and elements are separated by commas.                                                                                | Example:<br><br>`fruits = ["apple", "banana", "orange", "mango"]`                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| del              | The `del` statement is used to remove an element from list. `del` statement removes the element at the specified index.                                                                                                                                     | Example:<br><br>`my_list = [10, 20, 30, 40, 50]` <br>`del my_list[2] # Removes the element at index 2 print(my_list)` <br>`# Output: [10, 20, 40, 50]`                                                                                                                                                                                                                                                                                                                                                           |
| extend()         | The `extend()` method is used to add multiple elements to a list. It takes an iterable (such as another list, tuple, or string) and appends each element of the iterable to the original list.                                                              | Syntax:<br><br>`list_name.extend(iterable)` <br><br><br>Example:<br><br>`fruits = ["apple", "banana", "orange"]` <br>`more_fruits = ["mango", "grape"]` <br>`fruits.extend(more_fruits)` <br>`print(fruits)`                                                                                                                                                                                                                                                                                                     |
| Indexing         | Indexing in a list allows you to access individual elements by their position. In Python, indexing starts from 0 for the first element and goes up to `length_of_list - 1`.                                                                                 | Example:<br><br>`my_list = [10, 20, 30, 40, 50]` <br>`print(my_list[0])` <br>`# Output: 10 (accessing the first element)` <br>`print(my_list[-1])` <br>`# Output: 50 (accessing the last element using negative indexing)`                                                                                                                                                                                                                                                                                       |
| insert()         | The `insert()` method is used to insert an element, to index.                                                                                                                                                                                               | Syntax:<br><br>`list_name.insert(index, element)` <br>  <br>Example:<br><br>`my_list = [1, 2, 3, 4, 5]` <br>`my_list.insert(2, 6)` <br>`print(my_list)`                                                                                                                                                                                                                                                                                                                                                          |
| Modifying a list | You can use indexing to modify or assign new values to specific elements in the list.                                                                                                                                                                       | Example:<br><br>`my_list = [10, 20, 30, 40, 50]` <br>`my_list[1] = 25 # Modifying the second element` <br>`print(my_list)` <br>`# Output: [10, 25, 30, 40, 50]`                                                                                                                                                                                                                                                                                                                                                  |
| pop()            | `pop()` method is another way to remove an element from a list in Python. It removes and returns the element at the specified index. If you don't provide an index to the `pop()` method, it will remove and return the last element of the list by default | Example 1:<br><br>`my_list = [10, 20, 30, 40, 50]` <br>`removed_element = my_list.pop(2) # Removes and returns the element at index 2` <br><br>`print(removed_element)` <br>`# Output: 30` <br>`print(my_list)` <br>`# Output: [10, 20, 40, 50]` <br><br>          <br>Example 2:<br><br>`my_list = [10, 20, 30, 40, 50]` <br>`removed_element = my_list.pop() # Removes and returns the last element` <br><br>`print(removed_element)` <br>`# Output: 50` <br>`print(my_list)` <br>`# Output: [10, 20, 30, 40]` |
| remove()         | To remove an element from a list. The `remove()` method removes the first occurrence of the specified value.                                                                                                                                                | Example:<br><br>`my_list = [10, 20, 30, 40, 50]` <br>`my_list.remove(30) # Removes the element 30` <br>`print(my_list)` <br>`# Output: [10, 20, 40, 50]`                                                                                                                                                                                                                                                                                                                                                         |
| reverse()        | The `reverse()` method is used to reverse the order of elements in a list                                                                                                                                                                                   | Example 1:<br><br>`my_list = [1, 2, 3, 4, 5]` <br>`my_list.reverse() print(my_list)` <br>`# Output: [5, 4, 3, 2, 1]`                                                                                                                                                                                                                                                                                                                                                                                             |
| Slicing          | You can use slicing to access a range of elements from a list.                                                                                                                                                                                              | Syntax:<br><br>`list_name[start:end:step]` <br><br>Example:<br><br>`my_list = [1, 2, 3, 4, 5]` <br><br>`print(my_list[1:4])` <br>`# Output: [2, 3, 4]`<br><br>`print(my_list[:3])`<br>`# Output: [1, 2, 3]`<br><br>`print(my_list[2:])` <br>`# Output: [3, 4, 5]`<br><br>`print(my_list[::2])` <br>`# Output: [1, 3, 5]`                                                                                                                                                                                         |
| sort()           | The `sort()` method is used to sort the elements of a list in ascending order. If you want to sort the list in descending order, you can pass the `reverse=True` argument to the `sort()` method.                                                           | Example 1:<br><br>`my_list = [5, 2, 8, 1, 9]` <br>`my_list.sort()` <br>`print(my_list)` <br>`# Output: [1, 2, 5, 8, 9]` <br><br><br>Example 2:<br><br>`my_list = [5, 2, 8, 1, 9]` <br>`my_list.sort(reverse=True)` <br>`print(my_list)` <br>`# Output: [9, 8, 5, 2, 1]`                                                                                                                                                                                                                                          |

#### Tuple

| Package/Method  | Description                                                                                                                                                                  | Code Example                                                                                                                                                                                                                      |
| --------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| count()         | The count() method for a tuple is used to count how many times a specified element appears in the tuple.                                                                     | Syntax:<br><br>`tuple.count(value)`          <br><br><br>Example:<br><br>`fruits = ("apple", "banana", "apple", "orange")`<br>`print(fruits.count("apple")) #Counts the number of times apple is found in tuple.`<br>`#Output: 2` |
| index()         | The index() method in a tuple is used to find the first occurrence of a specified value and returns its position (index). If the value is not found, it raises a ValueError. | Syntax:<br><br>`tuple.index(value)` <br>          <br><br>Example:<br><br>`fruits = ("apple", "banana", "orange","apple")`<br>`print(fruits.index("apple")) #Returns the index value at which apple is present.`<br>`#Output: 0`  |
| sum()           | The sum() function in Python can be used to calculate the sum of all elements in a tuple, provided that the elements are numeric (integers or floats).                       | Syntax:<br><br>`sum(tuple)` <br><br>Example:<br><br>`numbers = (10, 20, 5, 30)`<br>`print(sum(numbers))`<br>`#Output: 65`                                                                                                         |
| min() and max() | Find the smallest (min()) or largest (max()) element in a tuple.                                                                                                             | Example:<br><br>`numbers = (10, 20, 5, 30)`<br>`print(min(numbers))`  <br>`#Output: 5`<br>`print(max(numbers))`<br>`#Output: 30`                                                                                                  |
| len()           | Get the number of elements in the tuple using len().                                                                                                                         | Syntax:<br><br>`len(tuple)`<br><br>Example:<br><br>`fruits = ("apple", "banana", "orange")`<br>`print(len(fruits)) #Returns length of the tuple.`<br>`#Output: 3`                                                                 |

#### Dictionaries  

| Package/Method        | Description                                                                                                                                                            | Code Example                                                                                                                                                                                               |
| --------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Creating a Dictionary | A dictionary is a built-in data type that represents a collection of key-value pairs. Dictionaries are enclosed in curly braces `{}`.                                  | Example:<br><br>`dict_name = {}` <br>`person = { "name": "John",  "age": 30, "city": "New York"}`                                                                                                          |
| Accessing Values      | You can access the values in a dictionary using their corresponding `keys`.                                                                                            | Syntax:<br><br>`Value = dict_name["key_name"]`<br><br>Example:<br>`name = person["name"]`<br>`age = person["age"]`                                                                                         |
| Add or modify         | Inserts a new key-value pair into the dictionary. If the key already exists, the value will be updated; otherwise, a new entry is created.                             | Syntax:<br><br>`dict_name[key] = value`   <br><br>Example:<br><br>`person["Country"] = "USA" # A new entry will be created.`<br>`person["city"] = "Chicago"  # Update the existing value for the same key` |
| del                   | Removes the specified key-value pair from the dictionary. Raises a `KeyError` if the key does not exist.                                                               | Syntax:<br><br>`del dict_name[key]`<br><br><br>Example:<br><br>`del person["Country"]`                                                                                                                     |
| update()              | The `update()` method merges the provided dictionary into the existing dictionary, adding or updating key-value pairs.                                                 | Syntax:<br><br>`dict_name.update({key: value})`<br><br><br>Example:<br><br>`person.update({"Profession": "Doctor"})`                                                                                       |
| clear()               | The `clear()` method empties the dictionary, removing all key-value pairs within it. After this operation, the dictionary is still accessible and can be used further. | Syntax:<br><br>`dict_name.clear()`<br><br><br>Example:<br><br>`grades.clear()`                                                                                                                             |
| key existence         | You can check for the existence of a key in a dictionary using the `in` keyword                                                                                        | Example:<br><br>`if "name" in person:`<br>     `print("Name exists in the dictionary.")`                                                                                                                   |
| copy()                | Creates a shallow copy of the dictionary. The new dictionary contains the same key-value pairs as the original, but they remain distinct objects in memory.            | Syntax:<br><br>`new_dict = dict_name.copy()`<br> <br><br>Example:<br><br>`new_person = person.copy()`<br>`new_person = dict(person) # another way to create a copy of dictionary`                          |
| keys()                | Retrieves all keys from the dictionary and converts them into a list. Useful for iterating or processing keys using list methods.                                      | Syntax:<br><br>`keys_list = list(dict_name.keys())`<br> <br><br>Example:<br><br>`person_keys = list(person.keys())`                                                                                        |
| values()              | Extracts all values from the dictionary and converts them into a list. This list can be used for further processing or analysis.                                       | Syntax:<br><br> `values_list = list(dict_name.values())`<br><br><br>Example:<br><br>`person_values = list(person.values())`                                                                                |
| items()               | Retrieves all key-value pairs as tuples and converts them into a list of tuples. Each tuple consists of a key and its corresponding value.                             | Syntax:<br><br>`items_list = list(dict_name.items())`<br>  <br><br>Example:<br><br>`info = list(person.items())`                                                                                           |

#### Sets

| Package/Method | Description                                                                                                                                                                             | Code Example                                                                                                                                                                                                                                                                                                                                                                                                              |
| -------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| add()          | Elements can be added to a set using the `add()` method. Duplicates are automatically removed, as sets only store unique values.                                                        | Syntax:<br><br>`set_name.add(element)` <br><br>Example:<br><br>`fruits.add("mango")`                                                                                                                                                                                                                                                                                                                                      |
| clear()        | The `clear()` method removes all elements from the set, resulting in an empty set. It updates the set in-place.                                                                         | Syntax:<br><br>`set_name.clear()` <br><br><br>Example:<br><br>`fruits.clear()`                                                                                                                                                                                                                                                                                                                                            |
| copy()         | The `copy()` method creates a shallow copy of the set. Any modifications to the copy won't affect the original set.                                                                     | Syntax:<br><br>`new_set = set_name.copy()` <br> <br><br>Example:<br><br>`new_fruits = fruits.copy()`                                                                                                                                                                                                                                                                                                                      |
| Defining Sets  | A set is an unordered collection of unique elements. Sets are enclosed in curly braces `{}`. They are useful for storing distinct values and performing set operations.                 | Example:<br><br>`empty_set = set() #Creating an Empty Set` <br>`fruits = {"apple", "banana", "orange"}`<br>`colors = ("orange", "red", "green")`<br>  <br><br>**Note:** These two sets will be used in the examples that follow.                                                                                                                                                                                          |
| discard()      | Use the `discard()` method to remove a specific element from the set. Ignores if the element is not found.                                                                              | Syntax:<br><br>`set_name.discard(element)` <br><br><br>Example:<br><br>`fruits.discard("apple")`                                                                                                                                                                                                                                                                                                                          |
| issubset()     | The `issubset()` method checks if the current set is a subset of another set. It returns True if all elements of the current set are present in the other set, otherwise False.         | Syntax:<br><br>`is_subset = set1.issubset(set2)`<br><br><br>Example:<br><br>`is_subset = fruits.issubset(colors)`                                                                                                                                                                                                                                                                                                         |
| issuperset()   | The `issuperset()` method checks if the current set is a superset of another set. It returns True if all elements of the other set are present in the current set, otherwise False.     | Syntax:<br><br>`is_superset = set1.issuperset(set2)` <br><br><br>Example:<br><br>`is_superset = colors.issuperset(fruits)`                                                                                                                                                                                                                                                                                                |
| pop()          | The `pop()` method removes and returns an arbitrary element from the set. It raises a `KeyError` if the set is empty. Use this method to remove elements when the order doesn't matter. | Syntax:<br><br>`removed_element = set_name.pop()` <br><br><br>Example:<br><br>`removed_fruit = fruits.pop()`                                                                                                                                                                                                                                                                                                              |
| remove()       | Use the `remove()` method to remove a specific element from the set. Raises a `KeyError` if the element is not found.                                                                   | Syntax:<br><br>`set_name.remove(element)` <br><br><br>Example:<br><br>`fruits.remove("banana")`                                                                                                                                                                                                                                                                                                                           |
| Set Operations | Perform various operations on sets: `union`, `intersection`, `difference`, `symmetric difference`.                                                                                      | Syntax:<br><br>`union_set = set1.union(set2)` <br>`intersection_set = set1.intersection(set2)` <br>`difference_set = set1.difference(set2)` <br>`sym_diff_set = set1.symmetric_difference(set2)` <br>        <br><br>Example:<br><br>`combined = fruits.union(colors)` <br>`common = fruits.intersection(colors)` <br>`unique_to_fruits = fruits.difference(colors)` <br>`sym_diff = fruits.symmetric_difference(colors)` |
| update()       | The `update()` method adds elements from another iterable into the set. It maintains the uniqueness of elements.                                                                        | Syntax:<br><br>`set_name.update(iterable)` <br><br>Example:<br><br>`fruits.update(["kiwi", "grape"])`                                                                                                                                                                                                                                                                                                                     |

## Clone or Copy Method
#### 🔹 1. **List**

- `a = b` → hanya alias, tidak membuat list baru.
- `a.copy()`, `a[:]`, `list(b)` → shallow copy.
- `copy.deepcopy(b)` → deep copy (untuk nested).

```python
import copy

a = [[1,2],[3,4]]
b = a          # alias
c = a.copy()   # shallow
d = copy.deepcopy(a)  # deep

b[0].append(99)
print(a)  # [[1,2,99],[3,4]] (ikut berubah)
print(c)  # [[1,2,99],[3,4]] (ikut berubah, shallow)
print(d)  # [[1,2],[3,4]]    (aman, deep copy)
```


#### 🔹 2. **Dict**

- `a = b` → alias.
- `dict(b)`, `b.copy()` → shallow copy.
- `copy.deepcopy(b)` → deep copy.

```python
import copy

person = {"name":"Ikhsan","skills":["Python"]}
alias = person
shallow = dict(person)
deep = copy.deepcopy(person)

alias["skills"].append("AI")
print(person)   # skills berubah
print(shallow)  # ikut berubah (shallow)
print(deep)     # tetap aman
```

#### 🔹 3. **Tuple**

- Tuple itu **immutable**, jadi:
    
    - `a = b` → alias, tapi aman karena tidak bisa diubah.
    - Copy (`tuple(b)`, slicing `[:]`) menghasilkan objek baru, tapi tidak ada bedanya dengan alias, kecuali kalau tuple berisi **mutable object** (misalnya list di dalam tuple).

```python
a = (1,2,3)
b = a[:]        # copy via slicing
print(a is b)   # True (Python optimize, tetap alias)

nested = ([1,2], [3,4])
copy_tuple = tuple(nested)
copy_tuple[0].append(99)
print(nested)   # ikut berubah, karena shallow
```

#### 🔹 4. **Set**

- `a = b` → alias.
- `a.copy()`, `set(b)` → shallow copy.
- `copy.deepcopy(b)` → deep copy.

```python
s = {1,2,3}
alias = s
shallow = s.copy()

alias.add(4)
print(s)      # {1,2,3,4}
print(shallow) # {1,2,3} (tidak ikut)
```

##### 📝 Tabel Ringkas

| Type      | `a = b` (alias)                                     | Shallow Copy                        | Deep Copy          |
| --------- | --------------------------------------------------- | ----------------------------------- | ------------------ |
| **List**  | Sama objek                                          | `a.copy()`, `a[:]`, `list(a)`       | `copy.deepcopy(a)` |
| **Dict**  | Sama objek                                          | `dict(a)`, `a.copy()`               | `copy.deepcopy(a)` |
| **Tuple** | Sama objek (immutable aman, kecuali nested mutable) | `tuple(a)`, `a[:]` (efek sama saja) | `copy.deepcopy(a)` |
| **Set**   | Sama objek                                          | `a.copy()`, `set(a)`                | `copy.deepcopy(a)` |
##### 📌 Kesimpulan

- `a = b` hanya membuat alias/reference, **tidak clone**.
- Shallow copy → buat objek baru 1 level, tapi nested masih shared.
- Deep copy → duplikat penuh ke dalam (nested object aman).
- Tuple biasanya aman karena immutable, tapi **kalau ada mutable di dalamnya** tetap bisa kena efek shallow vs deep.

## Glossary: Python Data Structures

| Term              | Definition                                                                                                                                                                                                                      |
| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Aliasing          | Aliasing refers to giving another name to a function or a variable.                                                                                                                                                             |
| Ampersand         | A character typically "&" standing for the word "and."                                                                                                                                                                          |
| Compound elements | Compound statements contain (groups of) other statements; they affect or control the execution of those other statements in some way.                                                                                           |
| Delimiter         | A delimiter in Python is a character or sequence of characters used to separate or mark the boundaries between elements or fields within a larger data structure, such as a string or a file.                                   |
| Dictionaries      | A dictionary in Python is a data structure that stores a collection of key-value pairs, where each key is unique and associated with a specific value.                                                                          |
| Function          | A function is a block of code, defining a set procedure, which is executed only when it is called.                                                                                                                              |
| Immutable         | Immutable Objects are of in-built datatypes like int, float, bool, string, Unicode, and tuple. In simple words, an immutable object can't be changed after it is created.                                                       |
| Intersection      | The intersection of two sets is a new set containing only the elements that are present in both sets.                                                                                                                           |
| Keys              | The keys () method in Python Dictionary, returns a view object that displays a list of all the keys in the dictionary in order of insertion using Python.                                                                       |
| Lists             | A list is any list of data items, separated by commas, inside square brackets.                                                                                                                                                  |
| Logic operations  | In Python, logic operations refer to the use of logical operators such as "and," "or," and "not" to perform logical operations on Boolean values (True or False).                                                               |
| Mutable           | Mutable objects in Python are objects whose values can be changed after they are created. These objects allow modifications such as adding, removing, or altering elements without creating a new object.                       |
| Nesting           | A nested function is simply a function within another function and is sometimes called an "inner function".                                                                                                                     |
| Ratings in python | Ratings in Python typically refer to a numerical or qualitative measure assigned to something to indicate its quality, performance, or value.                                                                                   |
| Set operations    | Set operations in Python refer to mathematical operations performed on sets, which are unordered collections of unique elements.                                                                                                |
| Sets in python    | A set is an unordered collection of unique elements.                                                                                                                                                                            |
| Syntax            | The rules that define the structure of the language for python is called its syntax.                                                                                                                                            |
| Tuples            | These are used store multiple items in a single variable.                                                                                                                                                                       |
| Type casting      | In python, this is converting one data type to another.                                                                                                                                                                         |
| Variables         | In python, a variable is a symbolic name or identifier used to store and manipulate data. Variables serve as containers for values, and these values can be of various data types, including numbers, strings, lists, and more. |
| Venn diagram      | A Venn diagram is a graphical representation that uses overlapping circles to illustrate the relationships and commonalities between sets or groups of items.                                                                   |
| Versatile data    | Versatile data, in a general context, refers to data that can be used in multiple ways, is adaptable to different applications or purposes, and is not restricted to a specific use case.                                       |

# Python Programming Fundamentals

## Summary

In this adventure into coding, we explored loops in Python - special tools that help us do things over and over again without getting tired. We met two types of loops: **"for loops"** and **"while loops."**

**For Loops** were like helpers that made us repeat tasks in order. We painted colors, counted numbers, and even got a helper to tell us where things were in a list. For loops made our job easier and made our code look cleaner.

**While Loops** were like detectives that kept doing something as long as a rule was true. They helped us take steps, guess numbers, and work until we were tired. While loops were like smart assistants that didn't stop until we said so.

- Python **conditions** use “if” statements to execute code based on true/false conditions created by comparisons and Boolean expressions.
- **Comparison** operations require using comparison operators such as == (equal to), > (greater than), and < (less than).
- Python uses the "!=" operator to determine whether two values are not equal.
- You can compare integers, strings, and floats.
- Python **branching** directs program flow by using conditional statements (for example, if, else, elif) to execute different code blocks based on conditions or tests.
- You can use the "if" statement with conditions to define actions if true.
- To perform actions when all previous conditions are false, you can use the "else" statement without a condition.
- The elif statement allows for additional checks only if the initial condition is false.
- To execute various operations on Boolean values, we use Boolean logic operators.
- Python **loops** are control structures that automate repetitive tasks and iterate over data structures like lists or dictionaries.
- The **range**() function generates a sequence of numbers with a specified start, stop, and step value for loops in Python.
- A for loop in Python iterates over a sequence, such as a list, tuple, or string, and executes a block of code for each item in the sequence.
- A while loop in Python executes a block of code as long as a specified condition remains true.
- Python **functions** are reusable code blocks that perform specific tasks, take input parameters, and often return results, enhancing code modularity and reusability.
- You may or may not have written the codes that are often included in functions.
- Python has a set of built-in functions such as "len" to find the length of a sequence or "sum" to find the total sum of a sequence.
- The "sorted" function creates a new sorted list, while "sort" sorts items in the original list.
- You can also create your own functions in Python.
- To ensure clarity and organization and facilitate understanding and maintenance of the code, developers must document functions using a documentation string enclosed in three quotes.
- The help command will return the documentation defined for a particular function.
- A function can have multiple parameters.
- If a function does not include a return statement, it returns None by default.
- You can use the "pass" keyword in a function to indicate that it does nothing (a placeholder for future code).
- A function will usually perform more than one task.
- In Python, the scope of a **variable** determines where you can access or modify that variable. Global scope allows access from anywhere, while local scope restricts it to a block or function.
- In Python, a programmer defines a local variable within a specific block or function, which can only be accessed or modified within that block or function.
- In Python, a global variable is a variable defined at the top level of a program that any part of the code can access or modify. 
- **Exception** handling in Python is a mechanism for managing and responding to errors and exceptions that may occur during program execution, preventing them from crashing the program.
- In Python, you use the "try-except" statement to attempt a block of code and specify alternative actions to execute if an error occurs, allowing you to handle exceptions. 
- In Python, you use the "try-except-else" statement to attempt a block of code, handle exceptions in the "except" block, and execute code in the "else" block when no exceptions occur. 
- Python developers use the "try-except-else-finally" statement to attempt a block of code, catch exceptions in the "except" block, execute code in the "else" block when no exceptions occur, and ensure that the "finally" block always runs, regardless of whether exception was raised or not.
- In Python, **objects** are instances of classes that encapsulate data and behavior, serving as the foundation for creating and working with various data types and custom data structures.
- To determine the type of an object in Python, you can use the `type()` command.
- Methods may modify an object’s internal state, but the object’s type usually remains the same.
- **Classes** in Python are blueprints for creating objects, defining their attributes and methods, enabling code organization, and object-oriented programming.
- Function "**init**" is a special method used to initialize data attributes.
- We can create instances of a class in Python.
- Data attributes consist of the data defining the objects.
- Methods are functions that interact and change the data attributes.
- The method has a function that requires the self as well as other parameters.

## Conditions and Branching

### Objective:

In this reading, you delved into the most frequently used operator and the concept of conditional branching, which encompasses the utilization of `if` statements and `if-else` statements.
In this reading, you'll learn about:
1. Comparison operators
2. Branching
3. Logical operators

### Comparison operations

Comparison operations are essential in programming. They help compare values and make decisions based on the results.

#### Equality operator
The equality operator == checks if two values are equal. For example, in Python:
```python
age = 25
if age == 25:
	print("You are 25 years old.")
```
Here, the code checks if the variable age is equal to 25 and prints a message accordingly.

#### Inequality operator
The inequality operator `!=` checks if two values are not equal:
```python
if age != 30:
	print("You are not 30 years old.")
```
Here, the code checks if the variable age is not equal to 30 and prints a message accordingly.

#### Greater than and less than
You can also compare if one value is greater than another.
```python
if age>= 20:
	print("Yes, the Age is greater than 20")
```
Here, the code checks if the variable age is greater than or equal to 20 and prints a message accordingly.

### Branching

Branching is like making decisions in your program based on conditions. Think of it as real-life choices.

#### The IF statement

Consider a real-life scenario of entering a bar. If you're above a certain age, you can enter; otherwise, you cannot.
```python
age = 20
if age >= 21:
	print("You can enter the bar.")
else:
	print("Sorry, you cannot enter.")
```
Here, you are using the `if` statement to make a decision based on the age variable.

#### The ELIF Statement

Sometimes, there are multiple conditions to check. For example, if you're not old enough for the bar, you can go to a movie instead.
```python
if age >= 21:
	print("You can enter the bar.")
elif age >= 18:
	print("You can watch a movie.")
else:
	print("Sorry, you cannot do either.")
```

#### Real-life example: Automated Teller Machine (ATM)

When a user interacts with an ATM, the software in the ATM can use branching to make decisions based on the user's input. For example, if the user selects "Withdraw Cash" the ATM can branch into different denominations of bills to dispense based on the amount requested.
```python
user_choice = "Withdraw Cash"
if user_choice == "Withdraw Cash":
    amount = int(input("Enter the amount to withdraw: "))
    if amount % 10 == 0:
        print("Amount dispensed: ", amount)
    else:
        print("Please enter a multiple of 10.")
else:
    print("Thank you for using the ATM.")
```

### Logical operators

Logical operators help combine and manipulate conditions.

#### The NOT operator

##### Real-life example: Notification settings

In a smartphone's notification settings, you can use the NOT operator to control when to send notifications. For example, you might only want to receive notifications when your phone is not in "Do Not Disturb" mode.

The not operator negates a condition.
```python
is_do_not_disturb = True
if not is_do_not_disturb:
    send_notification("New message received")
```

#### The AND operator

##### Real-life example: Access control

In a secure facility, you can use the AND operator to check multiple conditions for access. To open a high-security door, a person might need both a valid ID card and a matching fingerprint.

The AND operator checks if all required conditions are true, like needing both keys to open a safe.
```python
has_valid_id_card = True
has_matching_fingerprint = True
if has_valid_id_card and has_matching_fingerprint:
    open_high_security_door()
```

#### The OR operator

##### Real-life example: Movie night decision

When planning a movie night with friends, you can use the OR operator to decide on a movie genre. You'll choose a movie if at least one person is interested.

The OR operator checks if at least one condition is true. It's like choosing between different movies to watch.
```python
friend1_likes_comedy = True
friend2_likes_action = False
friend3_likes_drama = False
if friend1_likes_comedy or friend2_likes_action or friend3_likes_drama:
    choose a movie()
```


## Introduction to Loops in Python

### Objectives

1. Understand Python loops.
2. How the loop Works
3. Learn about the needs for loop
4. Utilize Python's Range function.
5. Familiarize with Python's enumerate function.
6. Apply while loops for conditional tasks.
7. Distinguish appropriate loop selection.

### What is a Loop?

In programming, a loop is like a magic trick that allows a computer to do something over and over again. Imagine you are a magician's assistant, and your magician friend asks you to pull a rabbit out of a hat, but not just once - they want you to keep doing it until they tell you to stop. That is what loops do for computers - they repeat a set of instructions as many times as needed.

### How Loop works?

Here's how it works in Python:

![For loop flowchart](https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMDeveloperSkillsNetwork-PY0101EN-SkillsNetwork/labs/Module%203/images/forloop.png)

- **Start:** The for loop begins with the keyword for, followed by a variable that will take on each value in a sequence.
- **Condition:** After the variable, you specify the keyword in and a sequence, such as a list or a range, that the loop will iterate through.
- If **Condition True**:
1. The loop takes the first value from the sequence and assigns it to the variable.
2. The indented block of code following the loop header is executed using this value.
3. The loop then moves to the next value in the sequence and repeats the process until all values have been used.

- **Statement:** Inside the indented block of the loop, you write the statements that you want to repeat for each value in the sequence.
- **Repeat:** The loop continues to repeat the block of code for each value in the sequence until there are no more values left.
- If **Condition False**:
1. Once all values in the sequence have been processed, the loop terminates automatically.
2. The loop completes its execution, and the program continues to the next statement after the loop.

### The Need for Loops

Think about when you need to count from 1 to 10. Doing it manually is easy, but what if you had to count to a **million**? Typing all those numbers one by one would be a nightmare! This is where loops come in handy. They help computers repeat tasks quickly and accurately without getting tired.

### Main Types of Loops

#### For Loops

For loops are like a superhero's checklist. A for loop in programming is a control structure that allows the repeated execution of a set of statements for each item in a sequence, such as elements in a list or numbers in a range, enabling efficient iteration and automation of tasks

##### Syntax of for loop
```python
for val in sequence:
      # statement(s) to be executed in sequence as a part of the loop.
```

Here is an example of For loop.

Imagine you're a painter, and you want to paint a beautiful rainbow with seven colors. Instead of picking up each color one by one and painting the rainbow, you could tell a magical painter's assistant to do it for you. This is what a basic for loop does in programming.

##### We have a list of colours.
`colors = ["red", "orange", "yellow", "green", "blue", "indigo", "violet"]`

##### Let's print the colour name in the new line using for loop.
```python
for color in colors:
    print(color)
```

In this example, the for loop picks each color from the colors list and prints it on the screen. You don't have to write the same code for each color - the loop does it automatically!

Sometimes you do not want to paint a rainbow, but _you want to count the number of steps to reach your goal._ A range-based for loop is like having a friendly step counter that helps you reach your target. 

Here is how you might use a for loop to count from 1 to 10:
```python
for number in range(1, 11):
    print(number)
```
Here, the **range(1, 11)** generates a sequence from 1 to 10, and the for loop goes through each number in that sequence, printing it out. It's like taking 10 steps, and you're guided by the loop!

#### Range Function

The range function in Python generates an ordered sequence that can be used in loops. It takes one or two arguments:

- If given one argument (e.g., range(11)), it generates a sequence starting from 0 up to (but not including) the given number.
```python
for number in range(11):
    print(number)
```

- If given two arguments (e.g., range(1, 11)), it generates a sequence starting from the first argument up to (but not including) the second argument.
```python
for number in range(1, 11):
    print(number)
```

#### The Enumerated For Loop

Have you ever needed to keep track of both the item and its position in a list? An enumerated for loop comes to your rescue. It's like having a personal assistant who not only hands you the item but also tells you where to find it.

Consider this example:
```python
fruits = ["apple", "banana", "orange"]
for index, fruit in enumerate(fruits):
    print(f"At position {index}, I found a {fruit}")
```
With this loop, you not only get the fruit but also its position in the list. It's as if you have a magical guide pointing out each fruit's location!

#### While Loops

While loops are like a sleepless night at a friend's sleepover. Imagine you and your friends keep telling ghost stories until someone decides it's time to sleep. As long as no one says, "Let's sleep" you keep telling stories.  
A while loop works similarly - it repeats a task as long as a certain condition is true. It's like saying, "Hey computer, keep doing this until I say stop!"

##### Basic syntax of While Loop.
```python
while condition:
    # Code to be executed while the condition is true
    # Indentation is crucial to indicate the scope of the loop
```

For example, here's how you might use a while loop to count from 1 to 10:
```python
count = 1
while count <= 10:
    print(count)
    count += 1
```

here's a breakdown of the above code.

1. There is a variable named **count** initialized with the value 1.
2. The while loop is used to repeatedly execute a block of code as long as a given condition is True. In this case, the condition is **count <= 10**, meaning the loop will continue as long as count is less than or equal to 10.
3. Inside the loop:
    - The **print(count)** statement outputs the current value of the count variable.
    - The **count += 1** statement increments the value of count by 1. This step ensures that the loop will eventually terminate when count becomes greater than 10.
4. The loop will continue executing as long as the condition count <= 10 is satisfied.
5. The loop will print the numbers 1 to 10 in consecutive order since the print statement is inside the loop block and executed during each iteration.
6. Once count reaches 11, the condition count <= 10 will evaluate to False, and the loop will terminate.
7. The output of the code will be the numbers 1 to 10, each printed on a separate line.

### The Loop Flow

Both for and while loops have their special moves, but they follow a pattern:

- **Initialization:** You set up things like a starting point or conditions.
- **Condition:** You decide when the loop should keep going and when it should stop.
- **Execution:** You do the task inside the loop.
- **Update:** You make changes to your starting point or conditions to move forward.
- **Repeat:** The loop goes back to step 2 until the condition is no longer true.

### When to Use Each

**For Loops:** Use for loops when you know the number of iterations in advance and want to process each element in a sequence. They are best suited for iterating over collections and sequences where the length is known.

**While Loops:** Use while loops when you need to perform a task repeatedly as long as a certain condition holds true. While loops are particularly useful for situations where the number of iterations is uncertain or where you're waiting for a specific condition to be met.


## Exploring Python Functions

### Objectives:

By the end of this reading, you should be able to:

1. Describe the function concept and the importance of functions in programming
2. Write a function that takes inputs and performs tasks
3. Use built-in functions like len(), sum(), and others effectively
4. Define and use your functions in Python
5. Differentiate between global and local variable scopes
6. Use loops within the function
7. Modify data structures using functions

### Introduction to functions

A function is a fundamental building block that encapsulates specific actions or computations. As in mathematics, where functions take inputs and produce outputs, programming functions perform similarly. They take inputs, execute predefined actions or calculations, and then return an output.

##### Purpose of functions

Functions promote code modularity and reusability. Imagine you have a task that needs to be performed multiple times within a program. Instead of duplicating the same code at various places, you can define a function once and call it whenever you need that task. This reduces redundancy and makes the code easier to manage and maintain.

##### Benefits of using functions

**Modularity:** Functions break down complex tasks into manageable components  
**Reusability:** Functions can be used multiple times without rewriting code  
**Readability:** Functions with meaningful names enhance code understanding  
**Debugging:** Isolating functions eases troubleshooting and issue fixing  
**Abstraction:** Functions simplify complex processes behind a user-friendly interface  
**Collaboration:** Team members can work on different functions concurrently  
**Maintenance:** Changes made in a function automatically apply wherever it's used

### How functions take inputs, perform tasks, and produce outputs

##### Inputs (Parameters)

Functions operate on data, and they can receive data as input. These inputs are known as _parameters_ or _arguments_. Parameters provide functions with the necessary information they need to perform their tasks. Consider parameters as values you pass to a function, allowing it to work with specific data.
##### Performing tasks

Once a function receives its input (parameters), it executes predefined actions or computations. These actions can include calculations, operations on data, or even more complex tasks. The purpose of a function determines the tasks it performs. For instance, a function could calculate the sum of numbers, sort a list, format text, or fetch data from a database.
##### Producing outputs

After performing its tasks, a function can produce an output. This output is the result of the operations carried out within the function. It's the value that the function “returns” to the code that called it. Think of the output as the end product of the function's work. You can use this output in your code, assign it to variables, pass it to other functions, or even print it out for display.

***Example:***

Consider a function named `calculate_total` that takes two numbers as input (parameters), adds them together, and then produces the sum as the output. Here's how it works:
```python
def calculate_total(a, b):  # Parameters: a and b
    total = a + b           # Task: Addition
    return total            # Output: Sum of a and b

result = calculate_total(5, 7)  # Calling the function with inputs 5 and 7
print(result)  # Output: 12
```

### Python's built-in functions

Python has a rich set of built-in functions that provide a wide range of functionalities. These functions are readily available for you to use, and you don't need to be concerned about how they are implemented internally. Instead, you can focus on understanding what each function does and how to use it effectively.

##### Using built-in functions or Pre-defined functions

To use a built-in function, you simply call the function's name followed by parentheses. Any required arguments or parameters are passed into the function within these parentheses. The function then performs its predefined task and may return an output you can use in your code.

Here are a few examples of commonly used built-in functions:

**len():** Calculates the length of a sequence or collection
```python
string_length = len("Hello, World!")  # Output: 13
list_length = len([1, 2, 3, 4, 5])   # Output: 5
```

**sum():** Adds up the elements in an iterable (list, tuple, and so on)
```python
total = sum([10, 20, 30, 40, 50])  # Output: 150
```

**max():** Returns the maximum value in an iterable
```python
highest = max([5, 12, 8, 23, 16])  # Output: 23
```

**min():** Returns the minimum value in an iterable
```python
lowest = min([5, 12, 8, 23, 16])  # Output: 5
```

Python's built-in functions offer a wide array of functionalities, from basic operations like len() and sum() to more specialized tasks.

### Defining your functions

Defining a function is like creating your mini-program:
Use `def` followed by the function name and parentheses

Here is the syntax to define a function:
```python
def function_name():
    pass
```

A `"pass"` statement in a programming function is a placeholder or a no-op (no operation) statement. Use it when you want to define a function or a code block syntactically but do not want to specify any functionality or implementation at that moment.

- **Placeholder:** `"pass"` acts as a temporary placeholder for future code that you intend to write within a function or a code block.
- **Syntax Requirement:** In many programming languages like Python, using `"pass"` is necessary when you define a function or a conditional block. It ensures that the code remains syntactically correct, even if it doesn't do anything yet.
- **No Operation:** `"pass"` itself doesn't perform any meaningful action. When the interpreter encounters “pass”, it simply moves on to the next statement without executing any code.

##### Function Parameters:
- Parameters are like inputs for functions
- They go inside parentheses when defining the function
- Functions can have multiple parameters

Example:
```python
def greet(name):
    return "Hello, " + name

result = greet("Alice")
print(result)  # Output: Hello, Alice
```

##### Docstrings (Documentation Strings)

- Docstrings explain what a function does
- Placed inside triple quotes under the function definition
- Helps other developers understand your function

Example:
```python
def multiply(a, b):
    """
    This function multiplies two numbers.
    Input: a (number), b (number)
    Output: Product of a and b
    """
    print(a * b)
multiply(2,6)
```

##### Return statement

- Return gives back a value from a function
- Ends the function's execution and sends the result
- A function can return various types of data

Example:
```python
def add(a, b):
    return a + b

sum_result = add(3, 5)  # sum_result gets the value 8
```


### Understanding scopes and variables

Scope is where a variable can be seen and used:

- **Global Scope:** Variables defined outside functions; accessible everywhere
- **Local Scope:** Variables inside functions; only usable within that function

***Example:***
##### Part 1: Global variable declaration
```python
global_variable = "I'm global"
```
This line initializes a global variable called `global_variable` and assigns it the value "I'm global".

> Global variables are accessible throughout the entire program, both inside and outside functions.

##### Part 2: Function definition
```python
def example_function():
    local_variable = "I'm local"
    print(global_variable)  # Accessing global variable
    print(local_variable)   # Accessing local variable
```
Here, you define a function called `example_function()`.

Within this function:

- A local variable named local_variable is declared and initialized with the string value "I'm local." This variable is local to the function and can only be accessed within the function's scope.
- The function then prints the values of both the **global variable (global_variable) and the local variable (local_variable)**. It demonstrates that you can access global and local variables within a function.

##### Part 3: Function call
```python
example_function()
```
In this part, you call the `example_function()` by invoking it. This results in the function's code being executed.  
As a result of this function call, it will print the values of the global and local variables within the function.

##### Part 4: Accessing global variable outside the function
```python
print(global_variable)  # Accessible outside the function
```
After calling the function, you print the value of the global variable `global_variable` outside the function. **This demonstrates that global variables are accessible inside and outside of functions.**

##### Part 5: Attempting to access local variable outside the function
```python
print(local_variable)  # Error, local variable not visible here
```
In this part, you are attempting to print the value of the local variable `local_variable` outside of the function. However, this line would result in an error.

> Local variables are only visible and accessible within the scope of the function where they are defined.

Attempting to access them outside of that scope would raise a `"NameError"`.

### Using functions with loops

##### Functions and loops together

1. Functions can contain code with loops
2. This makes complex tasks more organized
3. The loop code becomes a repeatable function

Example:
```python
def print_numbers(limit):
    for i in range(1, limit+1):
        print(i)
print_numbers(5)  # Output: 1 2 3 4 5
```

##### Enhancing code organization and reusability

1. Functions group similar actions for easy understanding
2. Looping within functions keeps code clean
3. You can reuse a function to repeat actions

Example
```python
def greet(name):
    return "Hello, " + name
for _ in range(3):
    print(greet("Alice"))
```


### Modifying data structure using functions

You'll use Python and a list as the data structure for this illustration. In this example, you will create functions to add and remove elements from a list.

##### Part 1: Initialize an empty list
```python
# Define an empty list as the initial data structure
my_list = []
```
In this part, you start by creating an empty list named `my_list`. This empty list serves as the data structure that you will modify throughout the code.

##### Part 2: Define a function to add elements
```python
# Function to add an element to the list
def add_element(data_structure, element):
    data_structure.append(element)
```
Here, you define a function called `add_element`. This function takes two parameters:
- `data_structure`: This parameter represents the list to which you want to add an element
- `element`: This parameter represents the element you want to add to the list

Inside the function, you use the `append` method to add the provided element to the data_structure, which is assumed to be a list.

##### Part 3: Define a function to remove elements
```python
# Function to remove an element from the list
def remove_element(data_structure, element):
    if element in data_structure:
        data_structure.remove(element)
    else:
        print(f"{element} not found in the list.")
```
In this part, you define another function called `remove_element`. It also takes two parameters:

- `data_structure`: The list from which we want to remove an element
- `element`: The element we want to remove from the list

Inside the function, you use conditional statements to check if the element is present in the data_structure. If it is, you use the `remove` method to remove the first occurrence of the element. If it's not found, you print a message indicating that the element was not found in the list.

##### Part 4: Add elements to the list
```python
# Add elements to the list using the add_element function
add_element(my_list, 42)
add_element(my_list, 17)
add_element(my_list, 99)
```
Here, you use the `add_element` function to add three elements (42, 17, and 99) to the `my_list`. These are added one at a time using function calls.

##### Part 5: Print the current list
```python
# Print the current list
print("Current list:", my_list)
```
This part simply prints the current state of the `my_list` to the console, allowing us to see the elements that have been added so far.

##### Part 6: Remove elements from the list
```python
# Remove an element from the list using the remove_element function
remove_element(my_list, 17)
remove_element(my_list, 55)  # This will print a message since 55 is not in the list
```
In this part, you use the `remove_element` function to remove elements from the my_list. First, you attempt to remove 17 (which is in the list), and then you try to remove 55 (which is not in the list). **The second call to `remove_element` will print a message indicating that 55 was not found.**

##### Part 7: Print the updated list
```python
# Print the updated list
print("Updated list:", my_list)
```
Finally, you print the updated `my_list` to the console. This allows us to observe the modifications made to the list by adding and removing elements using the defined functions.

---

### 📌 Python Function Argument Cheatsheet

|Definisi Fungsi|Pemanggilan|Hasil di dalam fungsi (`args` atau `x`)|
|---|---|---|
|`def f(x):`|`f([1,2,3])`|`x = [1,2,3]` (list utuh)|
|`def f(x):`|`f((1,2,3))`|`x = (1,2,3)` (tuple utuh)|
|`def f(x):`|`f(1,2,3)`|❌ Error (argumen terlalu banyak)|
|`def f(*args):`|`f(1,2,3)`|`args = (1,2,3)` (tuple berisi 3 angka)|
|`def f(*args):`|`f([1,2,3])`|`args = ([1,2,3],)` (tuple 1 elemen: list)|
|`def f(*args):`|`f((1,2,3))`|`args = ((1,2,3),)` (tuple 1 elemen: tuple)|
|`def f(*args):`|`f(*[1,2,3])`|`args = (1,2,3)` (list di-_unpack_)|
|`def f(*args):`|`f(*(1,2,3))`|`args = (1,2,3)` (tuple di-_unpack_)|

#### 📝 Pola Umum

- **Tanpa `*` di definisi** → hanya bisa 1 argumen (apapun tipenya).
- **Dengan `*args`** → bisa banyak argumen, otomatis dikumpulkan jadi tuple.
- **Dengan `*` di pemanggilan** → iterable (list/tuple/set/string) di-_unpack_ jadi argumen terpisah.

Contoh terakhir (set & string juga ikut aturan sama):

```python
def f(*args):
    print(args)

f(*"HI")      # ('H','I')
f(*{1,2,3})   # (1,2,3) urutan acak karena set
```

⚡ Jadi, gampangnya:  
👉 **Asterisk di definisi** = kumpulkan argumen.  
👉 **Asterisk di pemanggilan** = buka iterable jadi argumen.

---


## Exception Handling in Python

### Objectives

1. Understanding Exceptions
2. Distinguishing Errors from Exceptions
3. Familiarity with Common Python Exceptions
4. Managing Exceptions Effectively

### What are exceptions?

**Exceptions** are alerts when something unexpected happens while running a program. It could be a mistake in the code or a situation that was not planned for. Python can raise these alerts automatically, but we can also trigger them on purpose using the raise command. The cool part is that we can prevent our program from crashing by handling exceptions.

### Errors vs. Exceptions

Hold on, what is the difference between errors and exceptions? Well, `errors` are usually big problems that come from the computer or the system. They often make the program stop working completely. On the other hand, `exceptions` are more like issues we can control. They happen because of something we did in our code and can usually be fixed, so the program keeps going.

Here is the difference between `Errors and exceptions`:-

|Aspect|Errors|Exceptions|
|---|---|---|
|**Origin**|Errors are typically caused by the environment, hardware, or operating system.|Exceptions are usually a result of problematic code execution within the program.|
|**Nature**|Errors are often severe and can lead to program crashes or abnormal termination.|Exceptions are generally less severe and can be caught and handled to prevent program termination.|
|**Handling**|Errors are not usually caught or handled by the program itself.|Exceptions can be caught using try-except blocks and dealt with gracefully, allowing the program to continue execution.|
|**Examples**|Examples include “SyntaxError” due to incorrect syntax or “NameError” when a variable is not defined.|Examples include “ZeroDivisionError” when dividing by zero, or “FileNotFoundError” when attempting to open a non-existent file.|
|**Categorization**|Errors are not classified into categories.|Exceptions are categorized into various classes, such as “ArithmeticError,” “IOError,” ValueError,” etc., based on their nature.|

### Common Exceptions in Python

Here are a few examples of exceptions we often run into and can handle using this tool:

- **ZeroDivisionError:** This error arises when an attempt is made to divide a number by zero. Division by zero is undefined in mathematics, causing an arithmetic error. For instance:  
    For example:
```python
result = 10 / 0 
print(result)
# Raises ZeroDivisionError
```

- **ValueError:** This error occurs when an inappropriate value is used within the code. An example of this is when trying to convert a non-numeric string to an integer:  
    For example:
```python
num = int("abc")
# Raises ValueError
```

- **FileNotFoundError:** This exception is encountered when an attempt is made to access a file that does not exist.  
    For example:
```python
with open("nonexistent_file.txt", "r") as file:
        content = file.read()   # Raises FileNotFoundError
```

- **IndexError:** An IndexError occurs when an index is used to access an element in a list that is outside the valid index range.  
    For example:
```python
my_list = [1, 2, 3]
value = my_list[1]  # No IndexError, within range
missing = my_list[5]  # Raises IndexError
```

- **KeyError:** The KeyError arises when an attempt is made to access a non-existent key in a dictionary.  
    For example:
```python
my_dict = {"name": "Alice", "age": 30}
value = my_dict.get("city")  # No KeyError, using .get() method
missing = my_dict["city"]  # Raises KeyError
```

- **TypeError:** The TypeError occurs when an object is used in an incompatible manner. An example includes trying to concatenate a string and an integer:  
    For example:
```python
result = "hello" + 5   
# Raises TypeError
```

- **AttributeError:** An AttributeError occurs when an attribute or method is accessed on an object that doesn't possess that specific attribute or method. For instance:  
    For example:
```python
text = "example"
length = len(text)  # No AttributeError, correct method usage
missing = text.some_method()  # Raises AttributeError
```

- **ImportError:** This error is encountered when an attempt is made to import a module that is unavailable. For example: `import non_existent_module`

---

> Note: **Please remember, the exceptions you will encounter are not limited to just these. There are many more in Python. However, there is no need to worry. By using the technique provided below and following the correct syntax, you will be able to handle any exceptions that come your way.**

---

### Handling Exceptions:

Python has a handy tool called `try and except` that helps us manage exceptions.

**Try and Except** : You can use the try and except blocks to prevent your program from crashing due to exceptions.

Here's how they work:

1. The code that may result in an exception is contained in the try block.
2. If an exception occurs, the code directly jumps to except block.
3. In the except block, you can define how to handle the exception gracefully, like displaying an error message or taking alternative actions.
4. After the except block, the program continues executing the remaining code.

#### Example: Attempting to divide by zero
```python
# using Try- except 
try:
    # Attempting to divide 10 by 0
    result = 10 / 0
except ZeroDivisionError:
    # Handling the ZeroDivisionError and printing an error message
    print("Error: Cannot divide by zero")
# This line will be executed regardless of whether an exception occurred
print("outside of try and except block")
```


## Python Objects and Classes

### Objectives

In this reading, you will learn about:
- Fundamental concepts of Python objects and classes.
- Structure of classes and object code.
- Real-world examples related to objects and classes.

### Introduction to classes and object

Python is an object-oriented programming (OOP) language that uses a paradigm centered around objects and classes.

Let's look at these fundamental concepts.

#### Classes

A class is a blueprint or template for creating objects. It defines the structure and behavior that its objects will have.

Think of a class as a cookie cutter and objects as the cookies cut from that template.

In Python, you can create classes using the `class` keyword.

#### Creating classes

When you create a class, you specify the `attributes`(data) and `methods` (functions) that objects of that class will have.  
`Attributes` are defined as variables within the class, and `methods` are defined as functions.  
For example,you can design a "Car" class with attributes such as "color" and "speed," along with methods like "accelerate."

#### Objects

An _object_ is a fundamental unit in Python that represents a real-world entity or concept.  
Objects can be tangible (like a car) or abstract (like a student's grade).

_Every object has two main characteristics:_

##### State

The _attributes or data_ that describe the object. For your "Car" object, this might include attributes like "color", "speed", and "fuel level".

##### Behavior

The _actions or methods_ that the object can perform. In Python, methods are functions that belong to objects and can change the object's state or perform specific operations.

#### Instantiating objects

- Once you've defined a class, you can create individual objects (instances) based on that class.
- Each object is independent and has its own set of attributes and methods.
- To create an object, you use the class name followed by parentheses, so: "my_car = Car()"

#### Interacting with objects

You interact with objects by calling their methods or accessing their attributes using dot notation.

For example, if you have a Car object named **my_car**, you can set its color with **my_car.color = "blue"** and accelerate it with **my_car.accelerate()** if there's an accelerate method defined in the class.

### Structure of classes and object code

> Please don't directly copy and use this code because it is a template for explanation and not for specific results.

#### Class declaration (class ClassName)

- The `class` keyword is used to declare a class in Python.
- `ClassName` is the name of the class, typically following CamelCase naming conventions.
```python
class ClassName:
```

#### Class attributes (class_attribute = value)

- Class attributes are variables shared among all class instances (objects).
- They are defined within the class but outside of any methods.
```python
class ClassName:
    # Class attributes (shared by all instances)
    class_attribute = value
```

#### Constructor method (def **init**(self, attribute1, attribute2, …):)

- The `__init__` method is a special method known as the constructor.
- It initializes the **instance attributes** (also called instance variables) when an object is created.
- The `self` parameter is the first parameter of the constructor, referring to the instance being created.
- **attribute1**, **attribute2**, and so on are parameters passed to the constructor when creating an object.
- Inside the constructor, `self.attribute1`, `self.attribute2`, and so on are used to assign values to instance attributes.
```python
class ClassName:
    # Class attributes (shared by all instances)
    class_attribute = value

    # Constructor method (initialize instance attributes)
    def __init__(self, attribute1, attribute2, ...):
        pass
        # ...
```

#### Instance attributes (self.attribute1 = attribute1)

- Instance attributes are variables that store data specific to each class instance.
- They are initialized within the `__init__` method using the self keyword followed by the attribute name.
- These attributes hold unique data for each object created from the class.
```python
class ClassName:
    # Class attributes (shared by all instances)
    class_attribute = value

    # Constructor method (initialize instance attributes)
    def __init__(self, attribute1, attribute2, ...):
        self.attribute1 = attribute1
        self.attribute2 = attribute2
        # ...
```


#### Instance methods (def method1(self, parameter1, parameter2, …):)

- Instance methods are functions defined within the class.
- They operate on the instance's data (instance attributes) and can perform actions specific to instances.
- The **self** parameter is required in instance methods, allowing them to access instance attributes and call other methods within the class.
```python
class ClassName:
    # Class attributes (shared by all instances)
    class_attribute = value

    # Constructor method (initialize instance attributes)
    def __init__(self, attribute1, attribute2, ...):
        self.attribute1 = attribute1
        self.attribute2 = attribute2
        # ...

    # Instance methods (functions)
    def method1(self, parameter1, parameter2, ...):
        # Method logic
        pass
```


> Using the same steps you can define multiple instance methods.
```python
class ClassName:
    # Class attributes (shared by all instances)
    class_attribute = value

    # Constructor method (initialize instance attributes)
    def __init__(self, attribute1, attribute2, ...):
        self.attribute1 = attribute1
        self.attribute2 = attribute2
        # ...

    # Instance methods (functions)
    def method1(self, parameter1, parameter2, ...):
        # Method logic
        pass

    def method2(self, parameter1, parameter2, ...):
        # Method logic
        pass
```


> Note: Now, you have successfully created a dummy class.

#### Creating objects (Instances)

- To create objects (instances) of the class, you call the class like a function and provide arguments the constructor requires.
- Each object is a distinct instance of the class, with its own instance attributes and the ability to call methods defined in the class.
```python
# Create objects (instances) of the class
object1 = ClassName(arg1, arg2, ...)
object2 = ClassName(arg1, arg2, ...)
```

#### Calling methods on objects

- In this section, you will call methods on objects, specifically `object1` and `object2`.
- The methods **method1** and **method2** are defined in the ClassName **class**, and you're calling them on **object1** and **object2** respectively.
- You pass values **param1_value** and **param2_value** as arguments to these methods. These arguments are used within the method's logic.

#### Method 1: Using dot notation

- This is the most straightforward way to call an object's method. In this, use the dot notation **(object.method())** to invoke the method on the object directly.
- For example, `result1 = object1.method1(param1_value, param2_value, ...)` calls method1 on object1.
```python
# Calling methods on objects
# Method 1: Using dot notation
result1 = object1.method1(param1_value, param2_value, ...)
result2 = object2.method2(param1_value, param2_value, ...)
```

#### Method 2: Assigning object methods to variables

- Here's an alternative way to call an object's method by assigning the method reference to a variable.
- `method_reference = object1.method1` assigns the method **method1** of **object1** to the variable **method_reference**.
- Later, call the method using the variable like this: **result3 = method_reference(param1_value, param2_value, …)**.
```python
# Method 2: Assigning object methods to variables
method_reference = object1.method1  # Assign the method to a variable
result3 = method_reference(param1_value, param2_value, ...)
```

#### Accessing object attributes

- Here, you are accessing an object's attribute using dot notation.
- `attribute_value = object1.attribute1` retrieves the value of the attribute **attribute1** from **object1** and assigns it to the variable **attribute_value**.
```python
# Accessing object attributes
attribute_value = object1.attribute1  # Access the attribute using dot notation
```

#### Modifying object attributes

- You will modify an object's attribute using dot notation.
- `object1.attribute2 = new_value` sets the attribute **attribute2** of **object1** to the new value **new_value**.
```python
# Modifying object attributes
object1.attribute2 = new_value  # Change the value of an attribute using dot notation
```

#### Accessing class attributes (shared by all instances)

- Finally, access a class attribute shared by all class instances.
- `class_attr_value = ClassName.class_attribute` accesses the class attribute `class_attribute` from the ClassName `class` and assigns its value to the variable.  
    `class_attr_value`.

```python
# Accessing class attributes (shared by all instances)
class_attr_value = ClassName.class_attribute
```

### Real-world example

- **class attribute** (tanpa `self`)
- **instance attribute** (pakai `self`)
- **local variable** (variabel biasa di dalam method)

```python
class Person:
    # Class attribute → shared untuk semua object
    species = "Homo sapiens"

    def __init__(self, name, age):
        # Instance attributes → unik per object
        self.name = name
        self.age = age

    def introduce(self):
        # Local variable → hanya hidup di method ini
        greeting = "Hello"
        print(greeting, ", my name is", self.name)

    def show_species(self):
        # Akses class attribute
        print("Species:", Person.species)


p1 = Person("Ikhsan", 30)
p2 = Person("Budi", 25)

# Instance attribute (pakai self)
print(p1.name)   # Ikhsan
print(p2.age)    # 25

# Class attribute (tanpa self)
print(Person.species)  # Homo sapiens
print(p1.species)      # Homo sapiens (bisa lewat instance juga)

# Local variable (hanya ada di dalam method)
p1.introduce()         # Hello , my name is Ikhsan
# print(p1.greeting)   # ❌ Error: 'Person' object has no attribute 'greeting'

```

- **`self.attr`** → **instance attribute**, unik per object (`p1.name` ≠ `p2.name`).
- **`ClassName.attr`** → **class attribute**, sama untuk semua object (`p1.species` = `p2.species`).
- **variabel lokal** (tanpa `self`, ditulis dalam method) → hanya ada di dalam method, hilang setelah method selesai.


Let's write a python program that simulates a simple car class, allowing you to create car instances, accelerate them, and display their current speeds.

1. Let's start by defining a `Car` class that includes the following attributes and methods:

- Class attribute `max_speed`, which is set to **120 km/h**.
- Constructor method `__init__` that takes parameters for the **car's make, model, color, and an optional speed (defaulting to 0)**. This method initializes instance attributes for make, model, color, and speed.
- Method `accelerate(self, acceleration)` that allows the car to accelerate. If the acceleration does not exceed the `max_speed`, update the **car's speed** attribute. Otherwise, set the speed to the **max_speed**.
- Method `get_speed(self)` that returns the current speed of the car.

```python
class Car:
	# Class attribute (shared by all instances)
     max_speed = 120  # Maximum speed in km/h
     # Constructor method (initialize instance attributes)
     def __init__(self, make, model, color, speed=0):
         self.make = make
         self.model = model
         self.color = color
         self.speed = speed  # Initial speed is set to 0
     # Method for accelerating the car
     def accelerate(self, acceleration):
         if self.speed + acceleration <= Car.max_speed:
             self.speed += acceleration
         else:
             self.speed = Car.max_speed
     # Method to get the current speed of the car
     def get_speed(self):
         return self.speed
```


2. Now, you will instantiate two objects of the `Car` class, each with the following characteristics:

- car1: **Make = "Toyota", Model = "Camry", Color = "Blue"**
- car2: **Make = "Honda", Model = "Civic", Color = "Red"**
```python
# Create objects (instances) of the Car class
car1 = Car("Toyota", "Camry", "Blue")
car2 = Car("Honda", "Civic", "Red")
```

3. Using the `accelerate` method, you will increase the speed of car1 by 30 km/h and car2 by 20 km/h.
```python
# Accelerate the cars
car1.accelerate(30)
car2.accelerate(20)
```
4. Lastly, you will display the current speed of each car by utilizing the `get_speed` method.
```python
# Print the current speeds of the cars
print(f"{car1.make} {car1.model} is currently at {car1.get_speed()} km/h.")
print(f"{car2.make} {car2.model} is currently at {car2.get_speed()} km/h.")
```


## Python Programming Fundamentals Cheat Sheet

| Package/Method                | Description                                                                                                                                           | Syntax and Code Example                                                                                                                                                                                                                                                                                                                                                                                                             |
| ----------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| AND                           | Returns `True` if both statement1 and statement2 are `True`. Otherwise, returns `False`.                                                              | Syntax:<br>`statement1 and statement2` <br><br>Example:<br>`marks = 90`<br>`attendance_percentage = 87`<br><br>`if marks >= 80 and attendance_percentage >= 85:`<br>    `print("qualify for honors")`<br>`else:`<br>   `print("Not qualified for honors")`<br><br>`# Output = qualify for honors`                                                                                                                                   |
| Class Definition              | Defines a blueprint for creating objects and defining their attributes and behaviors.                                                                 | Syntax:<br><br>`class ClassName: # Class attributes and methods` <br> <br><br>Example:<br>`class Person:` <br>    `def __init__(self, name, age):` <br>        `self.name = name` <br>        `self.age = age`                                                                                                                                                                                                                      |
| Define Function               | A `function` is a reusable block of code that performs a specific task or set of tasks when called.                                                   | Syntax:<br><br>`def function_name(parameters): # Function body` <br><br>Example:<br>`def greet(name): print("Hello,", name)`                                                                                                                                                                                                                                                                                                        |
| Equal(==)                     | Checks if two values are equal.                                                                                                                       | Syntax:<br>`variable1 == variable2` <br><br>Example 1:<br>`5 == 5` <br>        <br>returns True<br><br>Example 2:<br>`age = 25` <br>`age == 30` <br><br>returns False                                                                                                                                                                                                                                                               |
| For Loop                      | A `for` loop repeatedly executes a block of code for a specified number of iterations or over a sequence of elements (list, range, string, etc.).     | Syntax:<br>`for variable in sequence: # Code to repeat` <br><br>Example 1:<br>`for num in range(1, 10):` <br>    `print(num)` <br><br>Example 2:<br>`fruits = ["apple", "banana", "orange", "grape", "kiwi"]` <br>`for fruit in fruits:`<br>    `print(fruit)`                                                                                                                                                                      |
| Function Call                 | A function call is the act of executing the code within the function using the provided arguments.                                                    | Syntax:<br>`function_name(arguments)` <br><br>Example:<br>`greet("Alice")`                                                                                                                                                                                                                                                                                                                                                          |
| Greater Than or Equal To(>=)  | Checks if the value of variable1 is greater than or equal to variable2.                                                                               | Syntax:<br>`variable1 >= variable2` <br><br>Example 1:<br>`5 >= 5 and 9 >= 5` <br><br>returns True<br><br>Example 2:<br>`quantity = 105` <br>`minimum = 100` <br>`quantity >= minimum` <br><br>returns True                                                                                                                                                                                                                         |
| Greater Than(>)               | Checks if the value of variable1 is greater than variable2.                                                                                           | Syntax:<br>`variable1 > variable2` <br><br>Example 1: <br>`9 > 6`<br><br>returns True<br><br>Example 2:<br>`age = 20` <br>`max_age = 25` <br>`age > max_age` <br><br>returns False                                                                                                                                                                                                                                                  |
| If Statement                  | Executes code block `if` the condition is `True`.                                                                                                     | Syntax:<br><br>`if condition: #code block for if statement` <br><br>Example:<br>`if temperature > 30:` <br>    `print("It's a hot day!")`                                                                                                                                                                                                                                                                                           |
| If-Elif-Else                  | Executes the first code block if condition1 is `True`, otherwise checks condition2, and so on. If no condition is `True`, the else block is executed. | Syntax:<br>`if condition1:`<br>`# Code if condition1 is True`<br><br>`elif condition2:`<br>`# Code if condition2 is True`<br><br>`else:`<br>`# Code if no condition is True`<br><br><br>Example:<br>`score = 85  # Example score`<br>`if score >= 90:`<br>    `print("You got an A!")`<br>`elif score >= 80:`<br>    `print("You got a B.")`<br>`else:`<br>    `print("You need to work harder.")`<br><br>`# Output = You got a B.` |
| If-Else Statement             | Executes the first code block if the condition is `True`, otherwise the second block.                                                                 | Syntax:<br><br>`if condition: # Code, if condition is True` <br>`else: # Code, if condition is False` <br><br><br>Example:<br>`if age >= 18:`<br>    `print("You're an adult.")`<br>`else:`<br>   `print("You're not an adult yet.")`                                                                                                                                                                                               |
| Less Than or Equal To(<=)     | Checks if the value of variable1 is less than or equal to variable2.                                                                                  | Syntax:<br>`variable1 <= variable2` 			 <br><br>Example 1:<br>`5 <= 5 and 3 <= 5` <br><br>returns True<br><br>Example 2:<br>`size = 38` <br>`max_size = 40` <br>`size <= max_size` <br><br>returns True                                                                                                                                                                                                                             |
| Less Than(<)                  | Checks if the value of variable1 is less than variable2.                                                                                              | Syntax:<br><br>`variable1 < variable2` <br><br>Example 1:<br>`4 < 6` <br><br>returns True<br><br>Example 2:<br>`score = 60` <br>`passing_score = 65` <br>`score < passing_score` <br><br>returns True                                                                                                                                                                                                                               |
| Loop Controls                 | `break` exits the loop prematurely. `continue` skips the rest of the current iteration and moves to the next iteration.                               | Syntax:<br>`for: # Code to repeat` <br>    `if # boolean statement`<br>        `break` <br><br>`for: # Code to repeat`  <br>    `if # boolean statement`<br>        `continue`<br><br>Example 1:<br>`for num in range(1, 6):`<br>    `if num == 3:`<br>        `break`<br>    `print(num)`<br><br>Example 2:<br>`for num in range(1, 6):`<br>    `if num == 3:`<br>        `continue`<br>    `print(num)`                           |
| NOT                           | Returns `True` if variable is `False`, and vice versa.                                                                                                | Syntax:<br>`not variable`<br><br>Example:<br>`isLocked = False`<br>`print(not isLocked)`  <br><br>returns True if the variable is False (i.e., unlocked).                                                                                                                                                                                                                                                                           |
| Not Equal(!=)                 | Checks if two values are not equal.                                                                                                                   | Syntax:<br>`variable1 != variable2` <br><br>Example:<br>`a = 10` <br>`b = 20` <br>`a != b` <br><br>returns True<br><br>Example 2:<br>`count=0` <br>`count != 0` <br><br>returns False                                                                                                                                                                                                                                               |
| Object Creation               | Creates an instance of a class (object) using the class constructor.                                                                                  | Syntax:<br>`object_name = ClassName(arguments)` <br><br>Example:<br>`person1 = Person("Alice", 25)`                                                                                                                                                                                                                                                                                                                                 |
| OR                            | Returns `True` if either statement1 or statement2 (or both) are `True`. Otherwise, returns `False`.                                                   | Syntax:<br>`statement1 or statement2`<br><br>Example:<br>`"Farewell Party Invitation"` <br>`grade = 12` <br>`if grade == 11 or grade == 12:`<br>    `print("Farewell Party Invitation")`<br>`else:`<br>    `print("Not eligible")` <br><br>returns True                                                                                                                                                                             |
| range()                       | Generates a sequence of numbers within a specified range.                                                                                             | Syntax:<br>`range(stop)` <br>`range(start, stop)` <br>`range(start, stop, step)` <br><br><br>Example:<br>`range(5) #generates a sequence of integers from 0 to 4.` <br>`range(2, 10) #generates a sequence of int from 2 to 9.` <br>`range(1, 11, 2) #generates odd integers from 1 to 9.`                                                                                                                                          |
| Return Statement              | `Return` is a keyword used to send a value back from a function to its caller.                                                                        | Syntax:<br>`return value` <br>    <br>Example:<br>`def add(a, b): return a + b` <br>`result = add(3, 5)`                                                                                                                                                                                                                                                                                                                            |
| Try-Except Block              | Tries to execute the code in the try block. If an exception of the specified type occurs, the code in the except block is executed.                   | Syntax:<br>`try: # Code that might raise an exception except` <br>`ExceptionType: # Code to handle the exception` <br><br>Example:<br>`try:` <br>    `num = int(input("Enter a number: "))` <br>`except ValueError:` <br>    `print("Invalid input. Please enter a valid number.")`                                                                                                                                                 |
| Try-Except with Else Block    | Code in the `else` block is executed if no exception occurs in the try block.                                                                         | Syntax:<br>`try: # Code that might raise an exception except` <br>`ExceptionType: # Code to handle the exception` <br>`else: # Code to execute if no exception occurs` <br>       <br>        <br>Example:<br>`try:` <br>    `num = int(input("Enter a number: "))` <br>`except ValueError:` <br>    `print("Invalid input. Please enter a valid number")` <br>`else:` <br>    `print("You entered:", num)`                         |
| Try-Except with Finally Block | Code in the `finally` block always executes, regardless of whether an exception occurred.                                                             | Syntax:<br>`try: # Code that might raise an exception except` <br>`ExceptionType: # Code to handle the exception` <br>`finally: # Code that always executes` <br><br><br>Example:<br>`try:` <br>    `file = open("data.txt", "r")` <br>    `data = file.read()` <br>`except FileNotFoundError:` <br>    `print("File not found.")` <br>`finally:` <br>    `file.close()`                                                            |
| While Loop                    | A `while` loop repeatedly executes a block of code as long as a specified condition remains `True`.                                                   | Syntax:<br>`while condition: # Code to repeat` <br><br>Example:<br>`count = 0` <br>`while count < 5:`<br>    `print(count)`<br>    `count += 1`                                                                                                                                                                                                                                                                                     |

### Glossary: Python Programming Fundamentals

Welcome! This alphabetized glossary contains many of the terms you'll find within this course. This comprehensive glossary also includes additional industry-recognized terms not used in course videos. These terms are important for you to recognize when working in the industry, participating in user groups, and participating in other certificate programs.

| Term                     | Definition                                                                                                                                                                                                                                                |
| ------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Analogy                  | Refers to a concept or comparison outside the scope of the programming language itself, used to explain or relate one concept to another in a more understandable way.                                                                                    |
| Attributes               | Attributes in Python refer to the characteristics or properties of an object, and they can be accessed using dot notation.                                                                                                                                |
| Branching                | Branching in Python is a process of altering the flow of a program based on conditions, typically using if, elif, and else statements.                                                                                                                    |
| Comparison operators     | Comparison operators in Python are used to compare values and return Boolean results (True or False), including operators like == (equal),!= (not equal), < (less than), > (greater than), <= (less than or equal to), and >= (greater than or equal to). |
| Conditions               | Conditions in Python are used to make decisions in code, executing specific blocks of code based on whether a given expression evaluates to True or False.                                                                                                |
| Enumerate                | In Python, "enumerate" is a built-in function that adds a counter to an iterable, allowing you to loop through both the elements and their corresponding indices.                                                                                         |
| Exception handling       | Exception handling in Python is a mechanism for gracefully managing and responding to errors or exceptional conditions that may occur during program execution.                                                                                           |
| Explicitly               | In Python, the term "explicitly" refers to performing an action or specifying something in a clear, unambiguous, and direct manner.                                                                                                                       |
| For loops                | For loops in Python are used for iterating over a sequence (such as a list, tuple, or string) or other iterable objects, executing a set of statements for each item in the sequence.                                                                     |
| Global variable          | Global variables in Python are variables defined outside of any function or block and can be accessed and modified from any part of the code.                                                                                                             |
| Incremented              | "Incremented" in Python means to increase the value of a variable by a specified amount, typically done using the += operator or by adding a fixed value.                                                                                                 |
| Indent                   | In Python, "indent" refers to the use of whitespace at the beginning of a line to signify the structure and scope of code blocks, such as loops and functions.                                                                                            |
| Indices                  | In Python, "indices" refer to the position or location of elements in a sequence, like a string, list, or tuple, starting with 0 for the first element.                                                                                                   |
| Iterate                  | In Python, "iterate" means to repeatedly perform a set of operations or steps on each item in a collection, such as a list, tuple, or dictionary, typically using loops or iterators.                                                                     |
| Local variables          | Local variables in Python are variables defined within a specific function or block of code and are only accessible within that function or block.                                                                                                        |
| Logic operators          | Logic operators in Python are used to perform logical operations on Boolean values, including operators like and (logical AND), or (logical OR), and not (logical NOT).                                                                                   |
| Loops                    | Loops in Python are constructs for repeating a block of code, enabling the execution of the same code multiple times.                                                                                                                                     |
| Parameters               | Parameters in Python are placeholders in a function definition, used to accept and work with values provided to the function when it is called.                                                                                                           |
| Programming Fundamentals | Programming fundamentals in Python involve variables, control structures, functions, data structures, input/output, and error handling for building software.                                                                                             |
| Range function           | The range function in Python generates a sequence of numbers that can be used for iterating in a loop and is typically used as range (start, stop, step), where it creates numbers from start to stop-1 with the given step increment.                    |
| Scope of function        | The "scope of a function" in Python refers to the region of code where a variable defined within that function is accessible or visible.                                                                                                                  |
| Sequences                | Sequences in Python are ordered collections of items that can include data types like strings, lists, and tuples, allowing for indexing and iteration.                                                                                                    |
| Syntax                   | In Python, "Syntax" refers to the set of rules that dictate how code must be written and structured to be correctly interpreted by the Python interpreter. It includes correct use of keywords, indentation, operators, and punctuation.                  |
| While loops              | While loops in Python are used to repeatedly execute a block of code as long as a specified condition is true.                                                                                                                                            |

# Working with Data in Python

## Summary

- Python uses the open() function and allows you to read and write files, providing access to the content within the file for reading. It also allows overwriting it for writing and specifies the file mode (for example, r for reading, w for writing, a for appending).
    
    - To read a file, Python uses an open function along with _r._
    - Python uses the **open with** function to read and process a file attribute, that is, from open to close.
    - In Python, you use the **open** method to edit or overwrite a file.
    - To write a file, Python uses the **open** function along with _w._
    - In Python, "a" indicates that the program has appended to the file.
    - In Python, “\n” signifies that the code should start on a new line. 
    - Python uses various methods to print lines from attributes.
        
- Pandas is a powerful Python library for data manipulation and analysis, providing data structures and functions to work with structured data like data frames and series.
    
    - You import the file (panda) by using the import command followed by the file name. 
        
    - In Python, you use the **as** command to provide a shorter name for the file.  
        
    - In Pandas, you use a data frame (df) to specify the files to read.
        
    - DataFrames consist of rows and columns.  
        
    - You can create new DataFrames by using the column or columns of a specific DataFrame.  
        
    - We can work with data in a DataFrames and save the results in different formats.
        
    - In Python, you use the **Unique** method to determine unique elements in a column of the DataFrames.
        
    - You use the inequality operator along with df to assign a Boolean value to the selected column in DataFrames. 
        
    - You save a new DataFrame as a different DataFrame, which may contain values from an earlier DataFrame.
        
- NumPy is a Python library for numerical and matrix operations, offering multidimensional array objects and a variety of mathematical functions to work with data efficiently.
    
    - NumPy is a basis for Pandas.
        
    - A NumPy array or ND array is similar to a list, usually of a fixed size with the same kind of element.
        
- A one-dimensional NumPy array is a linear sequence of elements with a single axis, like a traditional list, but optimized for numerical computations and array operations.
    
    - You can access elements in a NumPy using an index. 
        
    - You use the attribute **dtype** to get the data type of the array elements. 
        
    - You use **size** and **ndim** to get the size and dimension of the array, respectively. 
        
    - You can use indexing and slicing methods in NumPy. 
        
    - Vector additions are widely used operations in Python. 
        
    - Representing vector addition with line segments or arrows is useful.
        
    - NumPy codes work much faster, which is helpful with lots of data.
        
    - You perform vector subtraction by replacing the addition sign with a negative sign. 
        
    - Multiplying an array by a scalar in Python entails multiplying each element of the array by the scalar value, leading to a new array in which each element scales by the scalar.
        
    - Hadamard product refers to the element-wise multiplication of two arrays of the same shape, resulting in a new array where each element is the product of the corresponding elements in the input arrays.
        
    - The dot product in Python is the sum of the element-wise products of two arrays, often used for vector and matrix operations to find the scalar result of multiplying corresponding elements and summing them.
        
    - When working with NumPy, it is common to utilize libraries like Matplotlib to create graphs and visualizations from numerical data stored in NumPy arrays.
        
- A two-dimensional NumPy array is a grid-like structure with rows and columns suitable for representing data as a matrix or a table for numerical computations.
    
    - In NumPy, "shape" refers to an array's dimensions (number of rows and columns), indicating its size and structure.
        
    - You use the attribute "size" to obtain the size of an array. 
        
    - You use rectangular attributes to access the various elements in an array.
        
    -  You use a scalar to multiply elements in NumPy.